[{"content":"容器类 Java里提供好的可用的数据结构\n一系列不同功能的 由Java类库提供的用于管理对象的类\n都放在Java.util包里\n功能：\n 持有操作对象 自动完成容量的变化  容器类框架  \n Collection  列表（List）：按照一定次序（对象进入顺序） 排列的对象集，对象之间有次序关系，对象可以重复 集合（Set）：对象唯一，不会重复；元素没有顺序 队列（Queue）：根据排队规则确定对象的顺序   Map（映射表）：一群成对的对象集，这些对象各自保持着“键-值”（key-value）对应关系  Collection接口    方法 功能     add() 添加   remove() 移除   contains() 查看是否包含   addAll()    removeAll()    containAll()    retainAll() 取交集    ———————————\nQueue（队列） 一种先进先出（FIFO）的容器，从容器的一段放入对象，从另一端取出对象，并且放入和取出的顺序相同\n主要方法  offer()：（入队）如果可能，将指定的元素插入此队列 peek(),element()：在不移除的情况下返回队头。peek方法在队列为空的时候返回null,element方法在队列为空的时候抛出异常 poll(),remove()：（出队）移除并返回队头。pull方法在队列为空时返回null，remove方法在队头的时候抛出异常  主要实现类 LinkedList\n1 2  public class LinkedList\u0026lt;E\u0026gt; implements List\u0026lt;E\u0026gt;,Deque\u0026lt;E\u0026gt;   Deque接口（JDK6引入）：双端队列，是Queue的子接口\n实例\n1 2 3 4 5 6 7 8 9 10  Queue queue = new LinkedList(); queue.offer(\u0026#34;Hello\u0026#34;); queue.offer(\u0026#34;World!\u0026#34;); queue.offer(\u0026#34;你好！\u0026#34;); System.out.println(queue.size()); String str; while ((str = (String)queue.poll()) != null) { System.out.println(str); } System.out.println(queue.size());   输出：\n 3\nHello\nWorld!\n你好！\n0\n Set接口 Collection接口的子接口，未提供额外的方法\n理解：实际上Set就是Collection，只是行为不同（继承与多态思想的典型应用：表现不同的行为）\n实现Set接口类的特点：元素无顺序，不重复\n主要实现类 HashSet、TreeSet、LinkedHashSet\nHashSet 实例\n1 2 3 4 5 6  Set s = new HashSet(); s.add(new Student(1,\u0026#34;Tom\u0026#34;,70)); s.add(new Student(2,\u0026#34;Peter\u0026#34;,80)); s.add(new Student(3,\u0026#34;Bob\u0026#34;,90)); System.out.println(s.remove(new Student(1,\u0026#34;Tom\u0026#34;,70))); System.out.println(s);   输出：\n false\n[no is : 2, no is : 1, no is : 3]\n 原因：HashSet中使用hashCode、equals方法判断是否相同，为了提高效率，先调用hashCode方法（返回hashcode值），hashCode相同的才调用equals方法判断是否相同。\n为何使用hashCode：  在元素数量大的情况下，大大提高检索的效率 只有用到Hashtable、HashMap、HashSet、LinkedHashMap等时才要注意hashcode方法  对hashCode方法的要求 如果一个类要实现hashCode，必须和equals方法一块实现。hashCode方法和equals方法返回值的关系满足：\n equals()为true的两个对象，hashcode()返回值一定相等、 equals()不为true的两个对象，它们的hashCode()不一定相等。\n即equals()不为true的两个对象，hashCode()有可能相等。（哈希码在生成的时候可能产生冲突） hashCode()不等的两个对象，equals()不为true ；hashCode()相等，equals()可能为true ，也可能不为true  hashCode方法的重写 方法1：返回一个result\n1 2 3 4 5 6 7  public int hashCode() { int result = 17; //任意素数 result = 31*result +c1; //c1、c2：类的成员 result = 31*result +c2; …… return result; }    \nTreeSet 实现了Set接口，是Set的一个变体，是一个实现了排序功能的集合（类似于“插入排序”）。\n工作原理\n将对象元素添加到TreeSet中时会自动按照某种比较规则，将其插入到有序的对象序列中，以保证TreeSet集合元素组成的对象序列时刻按照“升序”排列；如果没指定排序规则，则会按照对象的hash编码来排序。\n排序规则\n CompareTo方法（自然排序）\nTreeSet只能接受实现了Comparable接口的类的对象 TeeeSet(Comparator\u0026lt;?super E\u0026gt;comparator)(定制排序)  实例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class Person { int age; public Person(int age) { this.age = age; } public String toString() { return \u0026#34;[age:\u0026#34; + age + \u0026#34;]\u0026#34;; } } class PersonComparator implements Comparator\u0026lt;Person\u0026gt;{ public int compare(Person m1, Person m2) { return m1.age \u0026gt; m2.age ? -1 : m1.age \u0026lt; m2.age ? 1 : 0; } } public static void main(String[] args) { TreeSet\u0026lt;Person\u0026gt; ts = new TreeSet\u0026lt;Person\u0026gt;(new PersonComparator()); ts.add(new Person(5)); ts.add(new Person(3)); ts.add(new Person(9)); System.out.println(ts); }   输出：\n [[age:9], [age:5], [age:3]]\n Map接口 特点：存储“键-值”对\n主要实现类：HashMap、TreeMap\nMap中“键值对”通过键标示，键要唯一，不重复\n 重复：equals为True（HashCode相等）  HashMap 基于哈希表实现了映射集合结构\n特点：不保证其中元素的先后顺序，并且允许使用“null”键和“null”值\n具体方法：Java HashMap|菜鸟教程\nHashTable 特点\n实现Map接口，与HashMap作用基本一样\nHashtable和HashMap的用法、格式完全相同\n与HashMap的区别：\n Hashtable是同步的，线程安全的，效率低一点；HashMap 不同步，效率较高，适合于单线程环境 Hashtable的键值都不能为null  Properties 1  public class Properties extends Hashtable\u0026lt;Object,Object\u0026gt;   作用\n处理属性文件（例如，Windows平台的ini文件）时方便；把Map对象和属性文件关联起来\n 可以把Map对象中的key-value对写入到属性文件 可以把属性文件中的“属性名=属性值”加载到Map对象中  key和value都是String类型\n实例：\n1 2 3 4 5 6 7 8 9 10 11 12 13  Properties props = new Properties(); // 向Properties中增加属性 props.setProperty(\u0026#34;username\u0026#34; , \u0026#34;admin\u0026#34;); props.setProperty(\u0026#34;password\u0026#34; , \u0026#34;123456\u0026#34;); // 将Properties中的key-value对保存到a.ini文件中 props.store(new FileOutputStream(\u0026#34;e:/gar/a.ini\u0026#34;),\u0026#34;用户名密码表\u0026#34;); // 新建一个Properties对象 Properties props2 = new Properties(); props2.load(new FileInputStream(\u0026#34;e:/gar/a.ini\u0026#34;) ); String username = props2.getProperty(\u0026#34;username\u0026#34;); String pwd = props2.getProperty(\u0026#34;password\u0026#34;); System.out.println(\u0026#34;用户名是：\u0026#34;+username+\u0026#34;，密码是：\u0026#34;+pwd);   输出：\n 用户名是：admin，密码是：123456\n 迭代器 以统一的方式遍历容器中的对象，程序员不必知道该容器的底层结构\nIterator接口 作用：以统一的方式对各种集合元素进行遍历、迭代\n实现Collection接口的容器类都有一个Iterator方法\n特点：只能前移\n     方法 功能     boolean hasNext( )    object next()    void remove()     实例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  Collection c = new HashSet(); c.add(new Student(1,\u0026#34;Tom\u0026#34;,60)); c.add(new Student(2,\u0026#34;Peter\u0026#34;,70)); c.add(new Student(3,\u0026#34;Bob\u0026#34;,80)); Iterator i = c.iterator(); while(i.hasNext()){ Student s = (Student)i.next(); System.out.println(s.getName()); } for(Iterator i = c.iterator();i.hasNext();){ Student s = (Student)i.next(); if(s.getNo()\u0026gt;2) { //不使用容器删除方法原因：删除对象后容器索引可能受到影响，不能保证准确性  i.remove(); } } System.out.println(c);   输出：\n Peter\nTom\n ListIterator接口 Iterator的子类型，功能更强大，只能用于各种List的访问\n特点：可以双向移动\n创建方法（来源于List）\n listIterator():产生一个指向List开始处的ListIterator listIterator(n):创建一个开始指向列表索引为n的元素处的listIterator。  实例:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  List all = new ArrayList(); all.add(\u0026#34;hello\u0026#34;); all.add(\u0026#34;_\u0026#34;); all.add(\u0026#34;world\u0026#34;); ListIterator iter = all.listIterator(); while (iter.hasNext()) { String str = (String)iter.next(); System.out.println(str + \u0026#34; \u0026#34;); } while (iter.hasPrevious()) { String str = (String)iter.previous(); System.out.println(str + \u0026#34; \u0026#34;); } ListIterator iter = all.listIterator(2); while(iter.hasNext()){ String s = (String)iter.next(); System.out.println(s); }   输出：\n hello\n_\nworld\nworld\n_\nhello\nworld\n 双向的迭代，但只适用于List接口\nEnumeration接口  不推荐使用\n 特点：与Iterator接口类似，但只提供了遍历Vector和HashTable（子类Properties）集合类型的功能，不支持集合元素的移除操作\nEnumeration接口在JDK 1.0推出，是最早的迭代输出接口，最早使用Vector时使用Enumeration接口进行输出的\n实用类 Collections类 类java.util.Collections提供了List容器操作的静态方法\n   方法 功能     void sort(List list); 对List容器内元素排序   void reverse(List list); 对List容器内的对象进行逆序排列   void copy(List dest,List src); 把src中List容器内容拷贝到dest List容器   int binarySearch(List list, Object key); 对顺序的List容器，用折半查找方法查找指定对象   void shuffle(List); 对List容器内的对象进行随机排序    实例：\n1 2 3 4 5 6 7 8 9 10 11 12  List list1 = new LinkedList(); for(int i=0;i\u0026lt;=9;i++){ list1.add(\u0026#34;a\u0026#34;+i); } System.out.println(list1); Collections.reverse(list1); System.out.println(list1); Collections.shuffle(list1); System.out.println(list1); Collections.sort(list1); System.out.println(Collections.binarySearch(list1,\u0026#34;a2\u0026#34;));   输出：\n [a0, a1, a2, a3, a4, a5, a6, a7, a8, a9]\n[a9, a8, a7, a6, a5, a4, a3, a2, a1, a0]\n[a1, a4, a3, a6, a9, a0, a8, a7, a2, a5]\n2\n Arrays类 功能：定义了多种数组操作方法，实现了对数组元素的排序、填充、转换为列表或字符串形式、增强的检索和深度比较等功能\n实例：\n1 2 3 4 5 6 7 8  Integer[] a = {3,25,12,79,48}; System.out.println(Arrays.toString(a)); Arrays.sort(a); System.out.println(Arrays.toString(a)); int idx = Arrays.binarySearch(a,25); System.out.println(idx); List list = Arrays.asList(3,4,5); System.out.println(list);   输出：\n [3, 25, 12, 79, 48]\n[3, 12, 25, 48, 79]\n2\n[3, 4, 5]\n ","date":"2021-06-11T13:09:38+08:00","permalink":"https://orilx.gitee.io/p/2021/06/java%E5%AE%B9%E5%99%A8/","title":"Java容器"},{"content":"String  常量字符串不放在堆中，放在数据区中 频繁改变字符串的内容会引起很大的内存开销 当需要改变字符串的内容时，String类的方法会返回一个新的String对象。\n如果String内容没有发生改变，String的相关方法只返回指向原有对象的引用。     方法 作用     S.charAt(num) 返回字符串中脚标为num的字符   S1.indexOf(S2) 返回字符串中关键字首字母的位置，如果没有则返回-1   S1.equalsIgnoreCase(S2) 忽略大小写比较两字符串   S.replace('c1','c2') 将字符串中所有字符c1换成c2   S.trim() 删掉字符串前后所有的空格   S1.startsWith(S2) 测试此字符串是否以指定的前缀开始   S1.endsWith(S2) 测试此字符串是否以指定的后缀结束   静态方法：String.valueOf(i) 将形参对应的值返回成String类型    Wrapper\u0026ndash;包装器类 Wrapper类对象的值初始化后不能改变\n实例1\n1 2 3 4 5  int x=1; String y = \u0026#34;2\u0026#34;; System.out.println(x+y); System.out.println(x+Integer.parseInt(y)); System.out.println(x+Integer.valueOf(y).intValue());   输出:\n 12\n3\n3\n 实例2\n1 2 3 4 5  int i = 1; Integer integer = 1; //自动封装（打包） System.out.println(integer); int j = integer; //自动解封（解包） System.out.println(j);   输出：\n 1\n enum\u0026ndash;枚举类 菜鸟教程-Java 枚举(enum)\n枚举是一个特殊的类，一般表示一组常量\n使用 enum 关键字来定义，各个常量使用逗号, 来分割\n枚举类型的主要方法：    方法 作用     name() 返回此枚举常量的名称   toString() 返回此枚举常量的名称   values() 获得该枚举类型的所有枚举变量   ordinal() 获取该枚举变量的编号    实例\n1 2 3 4 5 6 7 8 9 10 11  enum SEASON{ 春季,夏季,秋季,冬季 } public class Test { public static void main(String[] args) { SEASON[] t = SEASON.values(); for(SEASON s : t){ System.out.println(s); } } }   输出：\n 春季\n夏季\n秋季\n冬季\n 特点：\n 可以添加属性、方法 enum不能继承类（包括继承enum），只能实现接口；类无此限制，enum更像interface enum只支持public和[default] 访问修饰  ","date":"2021-06-07T23:25:38+08:00","permalink":"https://orilx.gitee.io/p/2021/06/%E5%B8%B8%E7%94%A8%E7%B1%BB/","title":"常用类"},{"content":"继承 父类构造方法不能被子类继承\n子类的构造方法中必须要调用父类的构造方法\n 子类通过super调用父类构造方法，调用super的语句必须放在子类构造方法的第一行 若子类构造方法中没有显式调用父类构造方法，则系统默认调用父类无参数构造方法；若父类中没有定义无参数的构造方法，编译出错  实例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  class A { A() { System.out.println(\u0026#34;A()\u0026#34;); } public void f() { System.out.println(\u0026#34;A:f()\u0026#34;); } } class B extends A{ B(){ System.out.println(\u0026#34;B()\u0026#34;); } public void f(){ System.out.println(\u0026#34;B:f()\u0026#34;); } } public static void main(String[ ] args) { B b = new B(); b.f(); }   输出结果为\n A()\nB()\nB:f()\n 子类不能直接访问父类的私有成员，但是可以通过继承自父类的有访问权限的方法或通过调用父类的构造子，间接访问这些私有成员。\nsuper 指向自己离自己最近的父类对象的一个引用\n作用：\n 第一种用法：在子类中调用父类的构造子\n*此时super必须是子类构造体中第一行可执行代码 第二种用法：引用父类中的成员和方法  对象转型 子类类型和父类类型之间的转换关系\n两种转换方式：\n 向上转型(upcasting) 向下转型(downcasting)  instanceof\n判断该引用所指对象是否属于该类或该类子类的对象\n实例 final  作用于类，禁止类被继承 作用于方法，禁止被子类重写 作用于属性，禁止属性被修改，相当于定义常量\n*final修饰的属性如果没有进行初始化，那么必须在构造子中对该属性进行一次初始化 作用于参数，可以有效防止方法内部对参数的二次赋值，保证数值的纯净度。  类的实例化过程 向上查找、向下创建\n 向上查找：从当前类开始逐级向上，直到找到最终父类为止。\n*通过构造子内部super调用，完成逐级向上的查找过程（直到Object类） 向下创建：从Object类开始逐级实例化  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  public class ClassA { public ClassA() { System.out.println(\u0026#34;New Instance of ClassA......\u0026#34;); } } public class ClassB extends ClassA { public ClassB() { System.out.println(\u0026#34;New Instance of ClassB......\u0026#34;); } } public class ClassC extends ClassB { public ClassC() { //\tsuper(); //调用父类的无参构造子 \tSystem.out.println(\u0026#34;New Instance of ClassC......\u0026#34;); } } public class Test { public static void main(String[] args) { //实例化ClassC \tClassC c=new ClassC(); } }   控制台输出:\n New Instance of ClassA\u0026hellip;\u0026hellip;\nNew Instance of ClassB\u0026hellip;\u0026hellip;\nNew Instance of ClassC\u0026hellip;\u0026hellip;\n 抽象类 可以包含抽象方法的类，叫做抽象类\n抽象方法规定子类必须做这件事，但是子类怎么做，抽象方法不限制。\n子类继承抽象类之后，必须通过方法重写，对继承自父类的抽象方法给出实现方案。\n接口 接口的定义和类类似，可以已有接口定义新的接口\n 方法无实现，不需要指定访问限制符（public） 属性是public static final类型 在实现接口的类中要实现接口中定义的所有抽象方法  多个无关的类可以实现同一个接口；一个类可以实现多个接口（多继承）\n接口无构造方法，不能直接实例化；允许有接口变量，可以指向实现了接口的类的对象，与实现类之间存在多态性。\n接口中的所有方法均采用默认访问权限。当子类实现接口以后，通过重写化抽象为具体，将该方法给出实现方法的时候，会将该方法的访问权限自动升级为public。所有接口方法无需编写访问权限修饰符。\n","date":"2021-05-27T18:07:37+08:00","permalink":"https://orilx.gitee.io/p/2021/05/java%E7%AC%94%E8%AE%B0/","title":"Java笔记"},{"content":"其余部分以后再补全\n先安装好git和Windows Terminal\n为啥用Windows Terminal？\n因为好看\n设置用户名和邮箱 git config --global user.name '名称'\rgit config --global user.email '邮箱地址' 生成密钥 ssh-keygen -t rsa -C '邮箱地址' 直接回车三次就行\n配置 打开用户文件夹/.ssh中的id-rsa.pub文件，复制密钥粘贴到GitHub账户Account settings -\u0026gt; SSH and GPG keys -\u0026gt; SSH keys 中\n克隆项目/托管本地项目 克隆 直接在要保存项目的文件夹中右键启动Windows Terminal，键入命令\ngit clone \u0026lt;项目ssh地址\u0026gt;\r托管本地项目 在项目文件夹下打开Windows Terminal，键入下面的命令进行初始化\ngit init\r完成后项目文件夹中会出现.git的隐藏文件夹\n在github/gitee中新建一个仓库，复制下ssh地址\n然后在命令行中输入\ngit remote add orign \u0026lt;项目ssh地址\u0026gt;\r","date":"2021-05-26T00:51:18Z","permalink":"https://orilx.gitee.io/p/2021/05/git%E7%9A%84%E9%85%8D%E7%BD%AE/","title":"git的配置"},{"content":"其余部分以后再补全\n安装scoop Scoop是Windows的命令行安装程序，是一个强大的包管理工具\n在powershell中运行命令\n1  Invoke-Expression (New-Object System.Net.WebClient).DownloadString(\u0026#39;https://get.scoop.sh\u0026#39;)   ps可能会报错\n PowerShell requires an execution policy in [Unrestricted, RemoteSigned, ByPass] to run Scoop. For example, to set the execution policy to \u0026lsquo;RemoteSigned\u0026rsquo; please run : \u0026lsquo;Set-ExecutionPolicy RemoteSigned -scope CurrentUser\u0026rsquo;\n 执行\n1  Set-ExecutionPolicy RemoteSigned -scope CurrentUser   之后再执行上面的命令即可\n安装Hugo 执行\n1 2 3  scoop install hugo #或 scoop install hugo-extended   即可\n安装主题 我使用的是jimmycaidalao制作的Stack主题\n在hugo根目录中执行命令\n1  git clone https://github.com/CaiJimmy/hugo-theme-stack/themes/hugo-theme-stack   具体配置参考配置文档\n部分hugo命令 1 2 3 4  hugo #在默认文件夹中生成静态网页 hugo server #生成本地预览网页(修改文章时可以动态刷新)   部分git命令 在public文件夹中执行\n1 2 3 4 5 6 7 8  git init #初始化(在第一次提交时执行，可以在.git文件夹中修改配置文件) git add . #将当前目录下所有文件提交到暂存区(注意后面有一个点) git commit -m [message] #将暂存区代码提交到仓库区并添加备注 git push #提交代码到远程仓库   ","date":"2021-05-26T00:47:00Z","permalink":"https://orilx.gitee.io/p/2021/05/hugo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/","title":"Hugo博客配置"},{"content":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026#34;profiles\u0026#34;: { \u0026#34;defaults\u0026#34;: { \u0026#34;acrylicOpacity\u0026#34;: 0.1, //背景透明度(0-1) \u0026#34;useAcrylic\u0026#34;: true, // 启用毛玻璃 \u0026#34;backgroundImage\u0026#34;: \u0026#34;D:\\\\0.0.jpg\u0026#34;, //背景图片 \u0026#34;backgroundImageOpacity\u0026#34;: 0.4, //图片透明度（0-1） \u0026#34;fontFace\u0026#34;: \u0026#34;Sarasa Term SC\u0026#34;, //字体 \u0026#34;fontSize\u0026#34;: 12, //文字大小 \u0026#34;fontWeight\u0026#34;: \u0026#34;bold\u0026#34;, //文字宽度，可设置加粗 \u0026#34;colorScheme\u0026#34;: \u0026#34;One Half Dark\u0026#34;, //主题名字 \u0026#34;antialiasingMode\u0026#34;: \u0026#34;cleartype\u0026#34; //消除文字锯齿 }, }   ","date":"2021-04-29T23:42:51Z","permalink":"https://orilx.gitee.io/p/2021/04/terminal%E7%BE%8E%E5%8C%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/","title":"Terminal美化配置文件"},{"content":"动态参数(可变参数) 动态参数在方法内部,可以当作数组处理\n在调用方法的时候,可以按如下三种方式进行调用:\n 接收数组 接收一个数据 接收n多个数据  以下面的代码串为例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  public class ParameterTest { public static void main(String[] args) { String pnames[]={\u0026#34;Steve\u0026#34;,\u0026#34;Amy\u0026#34;,\u0026#34;Alex\u0026#34;}; ParamaterTest.Select(pnames); //方式1  ParamaterTest.Select(\u0026#34;Steve\u0026#34;); //方式2  ParamaterTest.Select(\u0026#34;Steve\u0026#34;,\u0026#34;Amy\u0026#34;,\u0026#34;Alex\u0026#34;); //方式3  } public static void Select(String...pnames) { for(String name:pnames) { System.out.println(\u0026#34;Select \u0026#34;+name); } } }   分析 {% raw %}\n拓展:for-each循环数组\n基本语句:\n1 2 3 4  for ( 变量类型 变量名 : 数组名 ) { 需要执行的循环语句; }   其中变量类型与数组内元素类型相同\nfor-each循环会从下标为'0\u0026rsquo;的元素开始遍历,直到最后一个元素,并逐次将对应元素变量的值赋给前面设置的变量名里\n该方法相对于一般的for循环更加方便\n{% raw %}\n方式2\n此种接收方式等价于\n1 2  ParameterTest.Select(new String[]{\u0026#34;Steve\u0026#34;}) //匿名数组：定义数组的时候，没有起名   或者是\n1 2  String pnames[]={\u0026#34;Steve\u0026#34;}； ParamaterTest.Select(pnames);   方式3\n此种接收方式等价于\n1 2  String pnames[]={\u0026#34;Steve\u0026#34;,\u0026#34;Amy\u0026#34;,\u0026#34;Alex\u0026#34;} ; ParamaterTest.Select(pnames);   相当于新建了一个数组并对其赋值\n","date":"2021-03-01T22:50:31Z","permalink":"https://orilx.gitee.io/p/2021/03/%E6%96%B9%E6%B3%95%E7%9A%84%E5%8A%A8%E6%80%81%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8/","title":"方法的动态参数列表"},{"content":"程序设计中异常(Exception)与错误(Error)的区别  错误：语法层面的问题，由于语法应用不当或是编写不当导致代码无法编译运行 异常：由于逻辑设计上的思维错误，导致代码编译成功之后到运行期间，运行结果与设计意图不一致  以下面这段代码为例\n1 2 3 4 5 6 7 8 9 10 11 12  public static void main(String[] args) { Maths.div(); } private static void div() { int x=10; int y=0; int z=x/y; System.out.println(\u0026#34;z=\u0026#34;+z); }   上述代码在运行的时候会报错\nException in thread \u0026ldquo;main\u0026rdquo; java.lang.ArithmeticException: / by zero\nat com.openedu.Maths.div(Maths.java:146)\nat com.openedu.Maths.main(Maths.java:7)下面我们用新的方法重写这段代码\n带有完整的异常处理的方法 先上代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  private static void div2() { try { int x=10; int y=0; int z=x/y; System.out.println(\u0026#34;z=\u0026#34;+z); } catch(Exception ex)\t//ex表示try语句中异常的引用变量 \t{ //打印异常轨迹 \tex.printStackTrace(); System.out.println(\u0026#34;分母不能是0\u0026#34;); } finally { System.out.println(\u0026#34;finally code...\u0026#34;); } }   分析 try try代码块中编写正常执行的程序代码\ntry中任意一行代码一旦引发异常，从引发异常的这一行开始，之后的代码都不会运行。从引发异常的这一行直接跳转到catch部分，进行异常处理。\ncatch catch负责处理try中出现的异常\nfinally 可有可无~~（？）~~，无论异常是否出现，都会执行\n细节 1 2 3 4 5 6  catch(Exception ex)\t//ex表示try语句中异常的引用变量 { //打印异常轨迹 \tex.printStackTrace(); System.out.println(\u0026#34;分母不能是0\u0026#34;); }   由于所有的异常都是 Exception 的子类，依据动态方法调度原则，父类的变量可以引用子类的实例。因此，在 catch 后的括号里，定义一个 Exception 类型的变量，就可以使用该变量自动接收 try 产生的一切异常\n上述代码仍有缺陷\n 当方法引发异常的时候，没有通知main 违背软件开发中组件的职责划分  一个软件系统中，最小角色划分如下：\n 调用者：  调用正确的方法或组件 发出正确的指令   执行者：  正确执行调用者发出的指令 向调用者反馈执行结果    所以方法内部捕捉异常并直接处理，然后不向调用者汇报是错误的做法\n带有异常通知的异常处理体系 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  public static void main(String[] args) { //\tMaths.div3();\t//由于没有预处理，调用div3的时候会报错,需要在主函数中捕捉异常 \ttry { Maths.div3(); } catch(Exception ex) { System.out.println(\u0026#34;main方法捕捉异常\u0026#34;); ex.printStackTrace(); } } private static void div3()throws Exception { try { int x=10; int y=0; int z=x/y; System.out.println(\u0026#34;z=\u0026#34;+z); } catch(Exception ex)\t{ //将捕捉到的异常向调用者反馈---抛出异常 \tSystem.out.println(\u0026#34;div3中捕捉的异常\u0026#34;); ex.printStackTrace(); throw ex; } finally { System.out.println(\u0026#34;finally code...\u0026#34;); } }   输出结果：\ndiv3中捕捉的异常\njava.lang.ArithmeticException: / by zero\nat com.openedu.Maths.div3(Maths.java:39)\nat com.openedu.Maths.main(Maths.java:11)\njava.lang.ArithmeticException: / by zero\nfinally code\u0026hellip;\nmain方法捕捉异常\nat com.openedu.Maths.div3(Maths.java:39)\nat com.openedu.Maths.main(Maths.java:11)\n细节分析 throws Exception \u0026mdash; 声明异常 告诉调用者，本方法执行期间可能会出现异常，如果调用者调用本方法，请自行捕捉本方法可能出现的异常\n1 2 3 4 5 6 7  catch(Exception ex)\t{ //将捕捉到的异常向调用者反馈---抛出异常 \tSystem.out.println(\u0026#34;div3中捕捉的异常\u0026#34;); ex.printStackTrace(); throw ex; }   此时，如果 try 引发了异常， catch 模块捕捉到以后，通过 throw ex 将捕捉到的异常，通过异常声明向调用者抛出\n缺陷： 一个异常被处理了两次\n最终改进版的异常通知方案 上代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  public static void main(String[] args) { try { Maths.div4(); } catch(Exception ex) { System.out.println(\u0026#34;main方法捕捉异常\u0026#34;); ex.printStackTrace(); } } private static void div4() { //业务代码 \tint x=10; int y=0; int z=x/y; System.out.println(\u0026#34;z=\u0026#34;+z); }   分析 当 try 中的代码引发异常时，会自动寻找与 try 匹配的 catch 进行异常处理.而如果 try 没有对应的 catch 模块，那么 try 的异常就会自动通过异常声明向上级调用者反馈\n","date":"2021-02-28T00:00:00Z","permalink":"https://orilx.gitee.io/p/2021/02/java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","title":"Java中的异常处理"},{"content":"基本世界观 面向对象认为：客观世界就是基于一横一纵的两种关系构成的平面世界。\n纵向演进 同一物种，在繁衍生息过程中，不断壮大分裂，形成不同的种群，体现的就是物种的生生不息的纵向演化过程。\n每一次演进都是对已有物种重新分类的过程，比如生物学上的分类方式界门纲目科属种等，都是事物发展细分过程的体系。\n横向联系 同一物种的不同种群，或不同物种之间的联合和竞争\n 联合关系：A调用B 竞争关系：当A类存在后，经过实践证明，应用在某些环境下不是很好或存在隐患，于是开发新版本的替代方案，在A的不良应用环境中，取代之。  构成纵向演进和横向联系的主体就是对象。\n对象：客观世界的主体 对象也叫实体。\n在面向对象看来，客观世界的最小构成单元就是对象。一切事物都可以看作是对象，比如：一本书、一个人、一滴水、一个妖怪……\n简而言之，实体即对象。\n实体也是由两部分构成的，一个叫状态，一个叫行为，并且可以通过行为可以影响状态的改变。这就是面向对象编程的第一思想根基。\n即：行为影响状态，状态不可以自我更新。\n行为影响状态改变的三重含义  一个实体自身的行为，可以影响自身状态的改变，比如吃饭的行为影响饥饿状态的改变。 一个对象的行为可以影响其他对象状态的改变，比如老师讲课影响学生们清醒状态的改变。 状态的改变依赖于行为的发生，没有行为发生，状态不变，即状态不可以自我更新。  语法上的问题 没有对象级文件的原因 根据面向对象的理论体系，对象才是核心，但是，到目前为止，我们创建的都是类。\n在语法层面上就没有对象这一级的文件。比如在Eclipse中新建文件的选项中，就没有对象这一语法单元。原因是什么呢？\n对象的数量级，理论上是无穷的。针对无穷数量的东西，无法以可控的手段落实到语法单元层面，也无法维护。\n基于上述问题，一般采用物以类聚的原则，以类别为单位管理同类事物。这就是以类为基础语法单元的原因。\n类 类是面向对象的基本概念，是具有相同特征的对象的集合。\n概念解读 从任意主观角度去看，只要诸多对象存在相同的特征，就可以放到一起，作为一类事物进行统一管理。它体现的就是物以类聚的概念。\n类是一个集合的概念，表示的是群体特征。\n对象是这一类事物中的一个个体，是一类事物的一个实例。\n怎么设计类 思维的原点 任何思维模式都会有一个起点，由此开始向外衍射，逐渐形成理论体系。而最恰当的思维原点，就是事物的本源。从源头出发思考问题，往往能理清事物的发展脉络，更容易构建体系化的理论。即：一切思维，起始于物质本源，宜以便抓住源头，才能思考问题。\n面向对象思维原点 既然面向对象认为，客观世界最小单元是对象，因此一切理论的分析，都应该从对象开始。设计类自然也不例外，必须建立在对对象的分析这一基础上。\n设计的实现 面向对象程序设计 所谓的面向对象程序设计，就是分析客观实体的状态和行为抽象共性，形成类。\n 通过封装定义并区分事物的类别。 通过继承描述事物的纵向演进，描述类别细分。 通过多态描述基于物竞天择的物种多样性。 通过类（或对象）之间的调用，描述事物之间的横向联系。  类与类型 在Java中，定义一个类，就相当于定义了一种新的数据类型。对象可以看作是基于自定义类型创造的标准件。\n方法剖析 方法是什么 方法：对应事物的行为，封装了类对某一事件的处理过程。\n方法剖析的范围：\n 参数分析 返回值分析 重载分析  三驾马车 方法对应行为，事物的行为可能依赖于外界信息，参数用以收集为执行该行为所需要的外部信息；一个行为执行完毕以后，可能需要将执行结果通知给其他事物，这个要靠返回值来完成。\n简而言之：参数用以将数据带入方法，返回值用以将数据带出方法。\n参数分析 参数 代表方法执行期间接收的外部数据，可以是任意数据类型。比如int类型，String类型，以及自己定义的类型。\n参数的传递  值传递：方法内部对参数进行了改变，如果原始变量不变就是值传递（传递八大基本类型和String类型）。 引用传递：方法内部对参数进行了改变，如果原始变量的状态一并发生了变化，就是引用传递。  除了值传递之外的参数传递都是引用传递。\n可以简单理解为，当把对象作为参数进行传递的时候，就是引用传递。\n参数的扩展性 在实际应用中，参数应该具有一定的扩展性。具体表现在如下两个方法：\n 数量的扩展性 类型的扩展性  方法重载 什么是重载 在一个类内部，多个方块之间，同名不同参数即为方法重载。方法重载是构成面向对象多态的基石。\n重载只与参数有关，多个重载的方法，可以具有不同的返回值。\n重载的三大要素 以下满足其一不同，即可构成重载\n 参数个数 参数类型 参数顺序（参数数据类型的出现顺序不同）  两重含义 一个事物针对外界不同的刺激做出不同的反应，是类多态性的基础。\n针对同一行为给出不同解决方案，体现了类行为行为，在外界事件进行处理方面的灵活性。\n归属权分析 什么是归属权 归属权，也就是成员归类所有还是归对象所有。语法表象上就是成员是否是静态的(static)。\n如果是静态成员，表示该成员归类所有，通过类名就可以直接访问。\n如果是非静态成员，表示归对象所有，需要将类实例化以后，通过实例变量进行访问。\n静态成员调用的其他成员必须也是静态的；非静态成员可以调用静态成员。\n构造子分析 什么是构造子 构造子在类被实例化时自动调用，告诉外界按照什么标准将类实例化。\n构造子必须与类同名，没有明确定义构造子，那么在运行期间，Java会自动为该类提供一个默认构造子。\n默认构造子 就是空的无参构造子。\n 无参——表示没有参数 空的——表示构造子中没有可以执行的结构  注意事项  构造子可以私有 构造子可以重载  ","date":"2021-02-20T15:06:00Z","permalink":"https://orilx.gitee.io/p/2021/02/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0/","title":"Java面向对象笔记"},{"content":"六、列表 Markdown 支持有序列表和无序列表。\n无序列表使用星号 * 、加号 + 或是减号 - 作为列表标记，这些标记后面要添加一个空格，然后再填写内容：\n1 2 3 4 5 6 7 8 9 10 11  * 第一项 * 第二项 * 第三项 + 第一项 + 第二项 + 第三项 - 第一项 - 第二项 - 第三项   效果： 第一项 第二项 第三项   第一项 第二项 第三项   第一项 第二项 第三项  有序列表使用数字并加上 . 号来表示，如：\n1 2 3  1. 第一项 2. 第二项 3. 第三项   效果： 第一项 第二项 第三项  列表嵌套 要实现列表嵌套，只需在子列表中的选项前面添加四个空格：\n1 2 3 4 5 6  1. 第一项： - 第一项嵌套的第一个元素 - 第一项嵌套的第二个元素 2. 第二项： - 第二项嵌套的第一个元素 - 第二项嵌套的第二个元素   效果： 第一项：  第一项嵌套的第一个元素 第一项嵌套的第二个元素   第二项：  第二项嵌套的第一个元素 第二项嵌套的第二个元素    七、区块 在行首添加右尖括号 \u0026gt; 来生成区块\n1 2 3  \u0026gt; 区块引用 \u0026gt; 菜鸟教程 \u0026gt; 学的不仅是技术更是梦想   效果： 区块引用 菜鸟教程 学的不仅是技术更是梦想\n 区块可以嵌套，一个 \u0026gt; 号是最外层，两个 \u0026gt; 号是第一层嵌套，以此类推：\n1 2 3  \u0026gt; 最外层 \u0026gt; \u0026gt; 第一层嵌套 \u0026gt; \u0026gt; \u0026gt; 第二层嵌套   效果： 最外层\n 第一层嵌套\n 第二层嵌套\n   ▼区块中可以使用列表\n1 2 3 4 5 6  \u0026gt; 区块中使用列表 \u0026gt; 1. 第一项 \u0026gt; 2. 第二项 \u0026gt; + 第一项 \u0026gt; + 第二项 \u0026gt; + 第三项   效果： 区块中使用列表\n 第一项 第二项   第一项 第二项 第三项   ▼列表中也可以使用区块，此时要在 \u0026gt; 前添加四个空格（一个tab）的缩进\n1 2 3 4  * 第一项 \u0026gt; text \u0026gt; example * 第二项   效果： 第一项  text\nexample\n  第二项  八、表格 markdown中使用 | 来分隔不同的单元格，用 - 来分隔表头和其他行 语法格式如下：\n1 2 3 4  | 表头 | 表头 | | ---- | ---- | | 单元格 | 单元格 | | 单元格 | 单元格 |   对齐 对第二行进行修改可以设置表格的对齐方式\n1 2 3  -: 设置内容和标题栏居右对齐。 :- 设置内容和标题栏居左对齐。 :-: 设置内容和标题栏居中对齐。   1 2 3 4  | 左对齐 | 右对齐 | 居中对齐 | | :-----| ----: | :----: | | 单元格 | 单元格 | 单元格 | | 单元格 | 单元格 | 单元格 |   效果：   左对齐 右对齐 居中对齐     单元格 单元格 单元格   单元格 单元格 单元格   ","date":"2021-02-16T20:41:00Z","permalink":"https://orilx.gitee.io/p/2021/02/markdown%E7%AC%94%E8%AE%B0%E4%BA%8C/","title":"Markdown笔记(二)"},{"content":" Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。由约翰·格鲁伯（英语：John Gruber）创建。\nMarkdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。\nMarkdown 编写的文档后缀为 .md 或.markdown。 ——菜鸟教程\n 一、标题 1.1 使用#号标记 使用#号进行标题分级，注意#号后面要有一个空格。一个#号代表一级标题，两个代表二级，以此类推。\n▼下面是实例\n1 2 3 4 5 6  # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题   效果：1.2 使用 = 和 - 标记一级和二级标题 ▼下面是实例\n1 2 3 4  一级标题 ====== 二级标题 -----   效果：二、段落格式 2.1 段落 在markdown中换行，需要在行末加上两个以上的空格\n▼或者在两行之间空一行表示重新开始一个段落\n1 2 3  text text   效果：text\ntext\n2.2 文字格式 ▼在markdown中可以使用三种字体格式\n1 2 3  *斜体* **粗体** ***粗斜体***   效果：斜体\n粗体\n粗斜体\n其中*号可由下划线_代替\n2.3 其他 2.3.1 删除线 ▼要在文字上添加删除线，只需在文字两端加上两个~即可\n1  ~~删掉~~   效果：删掉\n2.3.2 下划线 Markdown 并无下划线的原生语法，因为会和链接的默认样式产生混淆。\n▼可使用HTML语法代替\n1  \u0026lt;u\u0026gt;示例\u0026lt;/u\u0026gt;   效果： 示例 2.3.3 分隔线 ▼可以在一行内使用三个以上的*号来生成分隔线(注意行内不能有其他的字符)\n1 2 3  ***   效果： (貌似和背景颜色混在一起看不出来了orz)text\n text\n还可以用以下几种写法生成分隔线\n1 2 3 4 5 6 7 8 9  *** * * * ***** - - - ----------   2.3.4 脚注 脚注是对文本的补充说明\n▼实例：\n1 2 3  咱是文本[^咱是脚注] [^咱是脚注]: 脚注   效果：咱是文本1\n三、代码 3.1 代码片段 ▼如果是段落中的代码片段，可以用反引号` 括起来\n1  `printf()` 函数   效果：printf() 函数\n{% raw %}{% endraw %}\n注：带有反引号的代码片段若要用高亮表示，需要用两个反引号括起来：1  `` ` ``   此处参考：https://www.cnblogs.com/zengjfgit/p/9006280.html\n3.2 代码区块 ▼用独立的两行```包裹一段代码来显示一个代码区块\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  public class CheckNumber { public static void main(String args[]) { CheckNumber.check(3); } public static void check(int n) { if(n%2==0)\t{ System.out.println(\u0026#34;Yes.\u0026#34;); } else { System.out.println(\u0026#34;No.\u0026#34;);\t} } }   四、链接 ▼使用方法\n1 2 3 4 5  [链接名称](链接地址) 或者 \u0026lt;链接地址\u0026gt;   例：这是一个链接 Dr.Ink https://orilx.github.io\n五、添加图片 语法格式如下：\n1 2 3  ![alt 属性文本](图片地址) ![alt 属性文本](图片地址 \u0026#34;可选标题\u0026#34;)   效果：markdown目前不支持对图片的大小进行调整，但我们可以通过HTML中的\u0026lt;img\u0026gt; 标签进行调整：\n1  \u0026lt;div style=\u0026#34;float:left;border:solid 1px 000;margin:2px;\u0026#34;\u0026gt;\u0026lt;img src=\u0026#34;https://github.com/Orilx/Orilx.github.io/blob/master/img/avatar.jpg?raw=true\u0026#34; width=\u0026#34;180\u0026#34; height=\u0026#34;200\u0026#34; \u0026gt;\u0026lt;/div\u0026gt;   效果：此处参考: MarkDown文档中怎么让图片并排展示\n  脚注\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"2021-02-16T16:41:00Z","permalink":"https://orilx.gitee.io/p/2021/02/markdown%E7%AC%94%E8%AE%B0%E4%B8%80/","title":"Markdown笔记(一)"},{"content":"2021-05-27更新\n折腾了好几次，终于可以在GitHub和Gitee上同时部署了\n2021-03-18更新\n给电脑重装了系统\nhexo博客又崩了\n花了两天时间迁移到hugo上\n2021-02-14\n折腾了一整天，终于把这个博客配置的差不多了\n剩下的细节以后再搞吧 (._. )\u0026gt;\n得找个时间把markdown学会了(￣﹃￣)","date":"2021-02-14T00:00:00Z","permalink":"https://orilx.gitee.io/p/2021/02/hello-world/","title":"Hello World!"}]