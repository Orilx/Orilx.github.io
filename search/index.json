[{"content":"其余部分以后再补全\n先安装好git和Windows Terminal\n为啥用Windows Terminal？\n因为好看\n设置用户名和邮箱 git config --global user.name '名称'\rgit config --global user.email '邮箱地址' 生成密钥 ssh-keygen -t rsa -C '邮箱地址' 直接回车三次就行\n配置 打开用户文件夹/.ssh中的id-rsa.pub文件，复制密钥粘贴到GitHub账户Account settings -\u0026gt; SSH and GPG keys -\u0026gt; SSH keys 中\n克隆项目/托管本地项目 克隆 直接在要保存项目的文件夹中右键启动Windows Terminal，键入命令\ngit clone \u0026lt;项目ssh地址\u0026gt;\r托管本地项目 在项目文件夹下打开Windows Terminal，键入下面的命令进行初始化\ngit init\r完成后项目文件夹中会出现.git的隐藏文件夹\n在github/gitee中新建一个仓库，复制下ssh地址\n然后在命令行中输入\ngit remote add orign \u0026lt;项目ssh地址\u0026gt;\r","date":"2021-05-26T00:51:18Z","permalink":"https://orilx.gitee.io/p/2021/05/git%E7%9A%84%E9%85%8D%E7%BD%AE/","title":"git的配置"},{"content":"其余部分以后再补全\n安装scoop Scoop是Windows的命令行安装程序，是一个强大的包管理工具\n在powershell中运行命令\n1  Invoke-Expression (New-Object System.Net.WebClient).DownloadString(\u0026#39;https://get.scoop.sh\u0026#39;)   ps可能会报错\n PowerShell requires an execution policy in [Unrestricted, RemoteSigned, ByPass] to run Scoop. For example, to set the execution policy to \u0026lsquo;RemoteSigned\u0026rsquo; please run : \u0026lsquo;Set-ExecutionPolicy RemoteSigned -scope CurrentUser\u0026rsquo;\n 执行\n1  Set-ExecutionPolicy RemoteSigned -scope CurrentUser   之后再执行上面的命令即可\n安装Hugo 执行\n1 2 3  scoop install hugo #或 scoop install hugo-extended   即可\n安装主题 我使用的是jimmycaidalao制作的Stack主题\n在hugo根目录中执行命令\n1  git clone https://github.com/CaiJimmy/hugo-theme-stack/themes/hugo-theme-stack   具体配置参考配置文档\n部分hugo命令 1 2 3 4  hugo #在默认文件夹中生成静态网页 hugo server #生成本地预览网页(修改文章时可以动态刷新)   部分git命令 在public文件夹中执行\n1 2 3 4 5 6 7 8  git init #初始化(在第一次提交时执行，可以在.git文件夹中修改配置文件) git add . #将当前目录下所有文件提交到暂存区(注意后面有一个点) git commit -m [message] #将暂存区代码提交到仓库区并添加备注 git push #提交代码到远程仓库   ","date":"2021-05-26T00:47:00Z","permalink":"https://orilx.gitee.io/p/2021/05/hugo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/","title":"Hugo博客配置"},{"content":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026#34;profiles\u0026#34;: { \u0026#34;defaults\u0026#34;: { \u0026#34;acrylicOpacity\u0026#34;: 0.1, //背景透明度(0-1) \u0026#34;useAcrylic\u0026#34;: true, // 启用毛玻璃 \u0026#34;backgroundImage\u0026#34;: \u0026#34;D:\\\\0.0.jpg\u0026#34;, //背景图片 \u0026#34;backgroundImageOpacity\u0026#34;: 0.4, //图片透明度（0-1） \u0026#34;fontFace\u0026#34;: \u0026#34;Sarasa Term SC\u0026#34;, //字体 \u0026#34;fontSize\u0026#34;: 12, //文字大小 \u0026#34;fontWeight\u0026#34;: \u0026#34;bold\u0026#34;, //文字宽度，可设置加粗 \u0026#34;colorScheme\u0026#34;: \u0026#34;One Half Dark\u0026#34;, //主题名字 \u0026#34;antialiasingMode\u0026#34;: \u0026#34;cleartype\u0026#34; //消除文字锯齿 }, }   ","date":"2021-04-29T23:42:51Z","permalink":"https://orilx.gitee.io/p/2021/04/terminal%E7%BE%8E%E5%8C%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/","title":"Terminal美化配置文件"},{"content":"动态参数(可变参数) 动态参数在方法内部,可以当作数组处理\n在调用方法的时候,可以按如下三种方式进行调用:\n 接收数组 接收一个数据 接收n多个数据  以下面的代码串为例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  public class ParameterTest { public static void main(String[] args) { String pnames[]={\u0026#34;Steve\u0026#34;,\u0026#34;Amy\u0026#34;,\u0026#34;Alex\u0026#34;}; ParamaterTest.Select(pnames); //方式1  ParamaterTest.Select(\u0026#34;Steve\u0026#34;); //方式2  ParamaterTest.Select(\u0026#34;Steve\u0026#34;,\u0026#34;Amy\u0026#34;,\u0026#34;Alex\u0026#34;); //方式3  } public static void Select(String...pnames) { for(String name:pnames) { System.out.println(\u0026#34;Select \u0026#34;+name); } } }   分析 {% raw %}\n拓展:for-each循环数组\n基本语句:\n1 2 3 4  for ( 变量类型 变量名 : 数组名 ) { 需要执行的循环语句; }   其中变量类型与数组内元素类型相同\nfor-each循环会从下标为'0\u0026rsquo;的元素开始遍历,直到最后一个元素,并逐次将对应元素变量的值赋给前面设置的变量名里\n该方法相对于一般的for循环更加方便\n{% raw %}\n方式2\n此种接收方式等价于\n1 2  ParameterTest.Select(new String[]{\u0026#34;Steve\u0026#34;}) //匿名数组：定义数组的时候，没有起名   或者是\n1 2  String pnames[]={\u0026#34;Steve\u0026#34;}； ParamaterTest.Select(pnames);   方式3\n此种接收方式等价于\n1 2  String pnames[]={\u0026#34;Steve\u0026#34;,\u0026#34;Amy\u0026#34;,\u0026#34;Alex\u0026#34;} ; ParamaterTest.Select(pnames);   相当于新建了一个数组并对其赋值\n","date":"2021-03-01T22:50:31Z","permalink":"https://orilx.gitee.io/p/2021/03/%E6%96%B9%E6%B3%95%E7%9A%84%E5%8A%A8%E6%80%81%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8/","title":"方法的动态参数列表"},{"content":"程序设计中异常(Exception)与错误(Error)的区别  错误：语法层面的问题，由于语法应用不当或是编写不当导致代码无法编译运行 异常：由于逻辑设计上的思维错误，导致代码编译成功之后到运行期间，运行结果与设计意图不一致  以下面这段代码为例\n1 2 3 4 5 6 7 8 9 10 11 12  public static void main(String[] args) { Maths.div(); } private static void div() { int x=10; int y=0; int z=x/y; System.out.println(\u0026#34;z=\u0026#34;+z); }   上述代码在运行的时候会报错\nException in thread \u0026ldquo;main\u0026rdquo; java.lang.ArithmeticException: / by zero\nat com.openedu.Maths.div(Maths.java:146)\nat com.openedu.Maths.main(Maths.java:7)下面我们用新的方法重写这段代码\n带有完整的异常处理的方法 先上代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  private static void div2() { try { int x=10; int y=0; int z=x/y; System.out.println(\u0026#34;z=\u0026#34;+z); } catch(Exception ex)\t//ex表示try语句中异常的引用变量 \t{ //打印异常轨迹 \tex.printStackTrace(); System.out.println(\u0026#34;分母不能是0\u0026#34;); } finally { System.out.println(\u0026#34;finally code...\u0026#34;); } }   分析 try try代码块中编写正常执行的程序代码\ntry中任意一行代码一旦引发异常，从引发异常的这一行开始，之后的代码都不会运行。从引发异常的这一行直接跳转到catch部分，进行异常处理。\ncatch catch负责处理try中出现的异常\nfinally 可有可无~~（？）~~，无论异常是否出现，都会执行\n细节 1 2 3 4 5 6  catch(Exception ex)\t//ex表示try语句中异常的引用变量 { //打印异常轨迹 \tex.printStackTrace(); System.out.println(\u0026#34;分母不能是0\u0026#34;); }   由于所有的异常都是 Exception 的子类，依据动态方法调度原则，父类的变量可以引用子类的实例。因此，在 catch 后的括号里，定义一个 Exception 类型的变量，就可以使用该变量自动接收 try 产生的一切异常\n上述代码仍有缺陷\n 当方法引发异常的时候，没有通知main 违背软件开发中组件的职责划分  一个软件系统中，最小角色划分如下：\n 调用者：  调用正确的方法或组件 发出正确的指令   执行者：  正确执行调用者发出的指令 向调用者反馈执行结果    所以方法内部捕捉异常并直接处理，然后不向调用者汇报是错误的做法\n带有异常通知的异常处理体系 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  public static void main(String[] args) { //\tMaths.div3();\t//由于没有预处理，调用div3的时候会报错,需要在主函数中捕捉异常 \ttry { Maths.div3(); } catch(Exception ex) { System.out.println(\u0026#34;main方法捕捉异常\u0026#34;); ex.printStackTrace(); } } private static void div3()throws Exception { try { int x=10; int y=0; int z=x/y; System.out.println(\u0026#34;z=\u0026#34;+z); } catch(Exception ex)\t{ //将捕捉到的异常向调用者反馈---抛出异常 \tSystem.out.println(\u0026#34;div3中捕捉的异常\u0026#34;); ex.printStackTrace(); throw ex; } finally { System.out.println(\u0026#34;finally code...\u0026#34;); } }   输出结果：\ndiv3中捕捉的异常\njava.lang.ArithmeticException: / by zero\nat com.openedu.Maths.div3(Maths.java:39)\nat com.openedu.Maths.main(Maths.java:11)\njava.lang.ArithmeticException: / by zero\nfinally code\u0026hellip;\nmain方法捕捉异常\nat com.openedu.Maths.div3(Maths.java:39)\nat com.openedu.Maths.main(Maths.java:11)\n细节分析 throws Exception \u0026mdash; 声明异常 告诉调用者，本方法执行期间可能会出现异常，如果调用者调用本方法，请自行捕捉本方法可能出现的异常\n1 2 3 4 5 6 7  catch(Exception ex)\t{ //将捕捉到的异常向调用者反馈---抛出异常 \tSystem.out.println(\u0026#34;div3中捕捉的异常\u0026#34;); ex.printStackTrace(); throw ex; }   此时，如果 try 引发了异常， catch 模块捕捉到以后，通过 throw ex 将捕捉到的异常，通过异常声明向调用者抛出\n缺陷： 一个异常被处理了两次\n最终改进版的异常通知方案 上代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  public static void main(String[] args) { try { Maths.div4(); } catch(Exception ex) { System.out.println(\u0026#34;main方法捕捉异常\u0026#34;); ex.printStackTrace(); } } private static void div4() { //业务代码 \tint x=10; int y=0; int z=x/y; System.out.println(\u0026#34;z=\u0026#34;+z); }   分析 当 try 中的代码引发异常时，会自动寻找与 try 匹配的 catch 进行异常处理.而如果 try 没有对应的 catch 模块，那么 try 的异常就会自动通过异常声明向上级调用者反馈\n","date":"2021-02-28T00:00:00Z","permalink":"https://orilx.gitee.io/p/2021/02/java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","title":"Java中的异常处理"},{"content":"基本世界观 面向对象认为：客观世界就是基于一横一纵的两种关系构成的平面世界。\n纵向演进 同一物种，在繁衍生息过程中，不断壮大分裂，形成不同的种群，体现的就是物种的生生不息的纵向演化过程。\n每一次演进都是对已有物种重新分类的过程，比如生物学上的分类方式界门纲目科属种等，都是事物发展细分过程的体系。\n横向联系 同一物种的不同种群，或不同物种之间的联合和竞争\n 联合关系：A调用B 竞争关系：当A类存在后，经过实践证明，应用在某些环境下不是很好或存在隐患，于是开发新版本的替代方案，在A的不良应用环境中，取代之。  构成纵向演进和横向联系的主体就是对象。\n对象：客观世界的主体 对象也叫实体。\n在面向对象看来，客观世界的最小构成单元就是对象。一切事物都可以看作是对象，比如：一本书、一个人、一滴水、一个妖怪……\n简而言之，实体即对象。\n实体也是由两部分构成的，一个叫状态，一个叫行为，并且可以通过行为可以影响状态的改变。这就是面向对象编程的第一思想根基。\n即：行为影响状态，状态不可以自我更新。\n行为影响状态改变的三重含义  一个实体自身的行为，可以影响自身状态的改变，比如吃饭的行为影响饥饿状态的改变。 一个对象的行为可以影响其他对象状态的改变，比如老师讲课影响学生们清醒状态的改变。 状态的改变依赖于行为的发生，没有行为发生，状态不变，即状态不可以自我更新。  语法上的问题 没有对象级文件的原因 根据面向对象的理论体系，对象才是核心，但是，到目前为止，我们创建的都是类。\n在语法层面上就没有对象这一级的文件。比如在Eclipse中新建文件的选项中，就没有对象这一语法单元。原因是什么呢？\n对象的数量级，理论上是无穷的。针对无穷数量的东西，无法以可控的手段落实到语法单元层面，也无法维护。\n基于上述问题，一般采用物以类聚的原则，以类别为单位管理同类事物。这就是以类为基础语法单元的原因。\n类 类是面向对象的基本概念，是具有相同特征的对象的集合。\n概念解读 从任意主观角度去看，只要诸多对象存在相同的特征，就可以放到一起，作为一类事物进行统一管理。它体现的就是物以类聚的概念。\n类是一个集合的概念，表示的是群体特征。\n对象是这一类事物中的一个个体，是一类事物的一个实例。\n怎么设计类 思维的原点 任何思维模式都会有一个起点，由此开始向外衍射，逐渐形成理论体系。而最恰当的思维原点，就是事物的本源。从源头出发思考问题，往往能理清事物的发展脉络，更容易构建体系化的理论。即：一切思维，起始于物质本源，宜以便抓住源头，才能思考问题。\n面向对象思维原点 既然面向对象认为，客观世界最小单元是对象，因此一切理论的分析，都应该从对象开始。设计类自然也不例外，必须建立在对对象的分析这一基础上。\n设计的实现 面向对象程序设计 所谓的面向对象程序设计，就是分析客观实体的状态和行为抽象共性，形成类。\n 通过封装定义并区分事物的类别。 通过继承描述事物的纵向演进，描述类别细分。 通过多态描述基于物竞天择的物种多样性。 通过类（或对象）之间的调用，描述事物之间的横向联系。  类与类型 在Java中，定义一个类，就相当于定义了一种新的数据类型。对象可以看作是基于自定义类型创造的标准件。\n方法剖析 方法是什么 方法：对应事物的行为，封装了类对某一事件的处理过程。\n方法剖析的范围：\n 参数分析 返回值分析 重载分析  三驾马车 方法对应行为，事物的行为可能依赖于外界信息，参数用以收集为执行该行为所需要的外部信息；一个行为执行完毕以后，可能需要将执行结果通知给其他事物，这个要靠返回值来完成。\n简而言之：参数用以将数据带入方法，返回值用以将数据带出方法。\n参数分析 参数 代表方法执行期间接收的外部数据，可以是任意数据类型。比如int类型，String类型，以及自己定义的类型。\n参数的传递  值传递：方法内部对参数进行了改变，如果原始变量不变就是值传递（传递八大基本类型和String类型）。 引用传递：方法内部对参数进行了改变，如果原始变量的状态一并发生了变化，就是引用传递。  除了值传递之外的参数传递都是引用传递。\n可以简单理解为，当把对象作为参数进行传递的时候，就是引用传递。\n参数的扩展性 在实际应用中，参数应该具有一定的扩展性。具体表现在如下两个方法：\n 数量的扩展性 类型的扩展性  方法重载 什么是重载 在一个类内部，多个方块之间，同名不同参数即为方法重载。方法重载是构成面向对象多态的基石。\n重载只与参数有关，多个重载的方法，可以具有不同的返回值。\n重载的三大要素 以下满足其一不同，即可构成重载\n 参数个数 参数类型 参数顺序（参数数据类型的出现顺序不同）  两重含义 一个事物针对外界不同的刺激做出不同的反应，是类多态性的基础。\n针对同一行为给出不同解决方案，体现了类行为行为，在外界事件进行处理方面的灵活性。\n归属权分析 什么是归属权 归属权，也就是成员归类所有还是归对象所有。语法表象上就是成员是否是静态的(static)。\n如果是静态成员，表示该成员归类所有，通过类名就可以直接访问。\n如果是非静态成员，表示归对象所有，需要将类实例化以后，通过实例变量进行访问。\n静态成员调用的其他成员必须也是静态的；非静态成员可以调用静态成员。\n构造子分析 什么是构造子 构造子在类被实例化时自动调用，告诉外界按照什么标准将类实例化。\n构造子必须与类同名，没有明确定义构造子，那么在运行期间，Java会自动为该类提供一个默认构造子。\n默认构造子 就是空的无参构造子。\n 无参——表示没有参数 空的——表示构造子中没有可以执行的结构  注意事项  构造子可以私有 构造子可以重载  ","date":"2021-02-20T15:06:00Z","permalink":"https://orilx.gitee.io/p/2021/02/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0/","title":"Java面向对象笔记"},{"content":"六、列表 Markdown 支持有序列表和无序列表。\n无序列表使用星号 * 、加号 + 或是减号 - 作为列表标记，这些标记后面要添加一个空格，然后再填写内容：\n1 2 3 4 5 6 7 8 9 10 11  * 第一项 * 第二项 * 第三项 + 第一项 + 第二项 + 第三项 - 第一项 - 第二项 - 第三项   效果： 第一项 第二项 第三项   第一项 第二项 第三项   第一项 第二项 第三项  有序列表使用数字并加上 . 号来表示，如：\n1 2 3  1. 第一项 2. 第二项 3. 第三项   效果： 第一项 第二项 第三项  列表嵌套 要实现列表嵌套，只需在子列表中的选项前面添加四个空格：\n1 2 3 4 5 6  1. 第一项： - 第一项嵌套的第一个元素 - 第一项嵌套的第二个元素 2. 第二项： - 第二项嵌套的第一个元素 - 第二项嵌套的第二个元素   效果： 第一项：  第一项嵌套的第一个元素 第一项嵌套的第二个元素   第二项：  第二项嵌套的第一个元素 第二项嵌套的第二个元素    七、区块 在行首添加右尖括号 \u0026gt; 来生成区块\n1 2 3  \u0026gt; 区块引用 \u0026gt; 菜鸟教程 \u0026gt; 学的不仅是技术更是梦想   效果： 区块引用 菜鸟教程 学的不仅是技术更是梦想\n 区块可以嵌套，一个 \u0026gt; 号是最外层，两个 \u0026gt; 号是第一层嵌套，以此类推：\n1 2 3  \u0026gt; 最外层 \u0026gt; \u0026gt; 第一层嵌套 \u0026gt; \u0026gt; \u0026gt; 第二层嵌套   效果： 最外层\n 第一层嵌套\n 第二层嵌套\n   ▼区块中可以使用列表\n1 2 3 4 5 6  \u0026gt; 区块中使用列表 \u0026gt; 1. 第一项 \u0026gt; 2. 第二项 \u0026gt; + 第一项 \u0026gt; + 第二项 \u0026gt; + 第三项   效果： 区块中使用列表\n 第一项 第二项   第一项 第二项 第三项   ▼列表中也可以使用区块，此时要在 \u0026gt; 前添加四个空格（一个tab）的缩进\n1 2 3 4  * 第一项 \u0026gt; text \u0026gt; example * 第二项   效果： 第一项  text\nexample\n  第二项  八、表格 markdown中使用 | 来分隔不同的单元格，用 - 来分隔表头和其他行 语法格式如下：\n1 2 3 4  | 表头 | 表头 | | ---- | ---- | | 单元格 | 单元格 | | 单元格 | 单元格 |   对齐 对第二行进行修改可以设置表格的对齐方式\n1 2 3  -: 设置内容和标题栏居右对齐。 :- 设置内容和标题栏居左对齐。 :-: 设置内容和标题栏居中对齐。   1 2 3 4  | 左对齐 | 右对齐 | 居中对齐 | | :-----| ----: | :----: | | 单元格 | 单元格 | 单元格 | | 单元格 | 单元格 | 单元格 |   效果：   左对齐 右对齐 居中对齐     单元格 单元格 单元格   单元格 单元格 单元格   ","date":"2021-02-16T20:41:00Z","permalink":"https://orilx.gitee.io/p/2021/02/markdown%E7%AC%94%E8%AE%B0%E4%BA%8C/","title":"Markdown笔记(二)"},{"content":" Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。由约翰·格鲁伯（英语：John Gruber）创建。\nMarkdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。\nMarkdown 编写的文档后缀为 .md 或.markdown。 ——菜鸟教程\n 一、标题 1.1 使用#号标记 使用#号进行标题分级，注意#号后面要有一个空格。一个#号代表一级标题，两个代表二级，以此类推。\n▼下面是实例\n1 2 3 4 5 6  # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题   效果：1.2 使用 = 和 - 标记一级和二级标题 ▼下面是实例\n1 2 3 4  一级标题 ====== 二级标题 -----   效果：二、段落格式 2.1 段落 在markdown中换行，需要在行末加上两个以上的空格\n▼或者在两行之间空一行表示重新开始一个段落\n1 2 3  text text   效果：text\ntext\n2.2 文字格式 ▼在markdown中可以使用三种字体格式\n1 2 3  *斜体* **粗体** ***粗斜体***   效果：斜体\n粗体\n粗斜体\n其中*号可由下划线_代替\n2.3 其他 2.3.1 删除线 ▼要在文字上添加删除线，只需在文字两端加上两个~即可\n1  ~~删掉~~   效果：删掉\n2.3.2 下划线 Markdown 并无下划线的原生语法，因为会和链接的默认样式产生混淆。\n▼可使用HTML语法代替\n1  \u0026lt;u\u0026gt;示例\u0026lt;/u\u0026gt;   效果： 示例 2.3.3 分隔线 ▼可以在一行内使用三个以上的*号来生成分隔线(注意行内不能有其他的字符)\n1 2 3  ***   效果： (貌似和背景颜色混在一起看不出来了orz)text\n text\n还可以用以下几种写法生成分隔线\n1 2 3 4 5 6 7 8 9  *** * * * ***** - - - ----------   2.3.4 脚注 脚注是对文本的补充说明\n▼实例：\n1 2 3  咱是文本[^咱是脚注] [^咱是脚注]: 脚注   效果：咱是文本1\n三、代码 3.1 代码片段 ▼如果是段落中的代码片段，可以用反引号` 括起来\n1  `printf()` 函数   效果：printf() 函数\n{% raw %}{% endraw %}\n注：带有反引号的代码片段若要用高亮表示，需要用两个反引号括起来：1  `` ` ``   此处参考：https://www.cnblogs.com/zengjfgit/p/9006280.html\n3.2 代码区块 ▼用独立的两行```包裹一段代码来显示一个代码区块\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  public class CheckNumber { public static void main(String args[]) { CheckNumber.check(3); } public static void check(int n) { if(n%2==0)\t{ System.out.println(\u0026#34;Yes.\u0026#34;); } else { System.out.println(\u0026#34;No.\u0026#34;);\t} } }   四、链接 ▼使用方法\n1 2 3 4 5  [链接名称](链接地址) 或者 \u0026lt;链接地址\u0026gt;   例：这是一个链接 Dr.Ink https://orilx.github.io\n五、添加图片 语法格式如下：\n1 2 3  ![alt 属性文本](图片地址) ![alt 属性文本](图片地址 \u0026#34;可选标题\u0026#34;)   效果：markdown目前不支持对图片的大小进行调整，但我们可以通过HTML中的\u0026lt;img\u0026gt; 标签进行调整：\n1  \u0026lt;div style=\u0026#34;float:left;border:solid 1px 000;margin:2px;\u0026#34;\u0026gt;\u0026lt;img src=\u0026#34;https://github.com/Orilx/Orilx.github.io/blob/master/img/avatar.jpg?raw=true\u0026#34; width=\u0026#34;180\u0026#34; height=\u0026#34;200\u0026#34; \u0026gt;\u0026lt;/div\u0026gt;   效果：此处参考: MarkDown文档中怎么让图片并排展示\n  脚注\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"2021-02-16T16:41:00Z","permalink":"https://orilx.gitee.io/p/2021/02/markdown%E7%AC%94%E8%AE%B0%E4%B8%80/","title":"Markdown笔记(一)"},{"content":"2021-03-18更新\n给电脑重装了系统\nhexo博客又崩了\n花了两天时间迁移到hugo上\n2021-02-14\n折腾了一整天，终于把这个博客配置的差不多了\n剩下的细节以后再搞吧 (._. )\u0026gt;\n得找个时间把markdown学会了(￣﹃￣)","date":"2021-02-14T00:00:00Z","permalink":"https://orilx.gitee.io/p/2021/02/hello-world/","title":"Hello World!"},{"content":"静态页面生成器\ndocsify/gitbook 文档适用\n","date":"0001-01-01T00:00:00Z","permalink":"https://orilx.gitee.io/p/1/01/","title":""}]